<html>
<head>
<title>data</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.7.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<pre>
<a href='../S/45.html#L208'>data</a>              208 Array.h              if (this-&gt;data() == array.data() &amp;&amp; same_length)
<a href='../S/44.html#L521'>data</a>              521 ReferenceCountedArray.h     inline const_pointer data() const { return constBuf(); }
<a href='../S/44.html#L537'>data</a>              537 ReferenceCountedArray.h     inline const_iterator begin() const { return const_iterator(data()); };
<a href='../S/44.html#L585'>data</a>              585 ReferenceCountedArray.h         _hash = ((_hash &lt;&lt; 5) + _hash) + hasher(this-&gt;data()[i]);
<a href='../S/54.html#L150'>data</a>              150 Stream.cpp       std::memcpy(map, str.data(), length());
<a href='../S/54.html#L158'>data</a>              158 Stream.cpp       if ((fwrite(str.data(), 1, length(), f) != length()) || (fflush(f))) {
<a href='../S/55.html#L46'>data</a>               46 String.cpp       if (data() == str.data() &amp;&amp; my_len == str.length())
<a href='../S/35.html#L161'>data</a>              161 String.h                 return data();
<a href='../S/46.html#L35'>data</a>               35 base64.c       void b64enc_buf(const unsigned char *data, size_t *len, char *dest, const char* charset)
<a href='../S/46.html#L68'>data</a>               68 base64.c           buf[0] = charset[(data[0] &amp; 0xfc) &gt;&gt; 2];
<a href='../S/46.html#L70'>data</a>               70 base64.c           buf[1] = charset[((data[0] &amp; 0x03) &lt;&lt; 4) | ((data[1] &amp; 0xf0) &gt;&gt; 4)];
<a href='../S/46.html#L72'>data</a>               72 base64.c           buf[2] = charset[((data[1] &amp; 0x0f) &lt;&lt; 2) | ((data[2] &amp; 0xc0) &gt;&gt; 6)];
<a href='../S/46.html#L74'>data</a>               74 base64.c           buf[3] = charset[data[2] &amp; 0x3f];
<a href='../S/46.html#L76'>data</a>               76 base64.c           data += NUM_ASCII_BYTES;
<a href='../S/46.html#L83'>data</a>               83 base64.c           buf[0] = charset[(data[0] &amp; 0xfc) &gt;&gt; 2];
<a href='../S/46.html#L85'>data</a>               85 base64.c             buf[1] = charset[((data[0] &amp; 0x03) &lt;&lt; 4)];
<a href='../S/46.html#L89'>data</a>               89 base64.c             buf[1] = charset[((data[0] &amp; 0x03) &lt;&lt; 4) | ((data[1] &amp; 0xf0) &gt;&gt; 4)];
<a href='../S/46.html#L90'>data</a>               90 base64.c             buf[2] = charset[(data[1] &amp; 0x0f) &lt;&lt; 2];
<a href='../S/46.html#L101'>data</a>              101 base64.c         char *p = b64enc(reinterpret_cast&lt;const unsigned char*&gt;(string.data()), &amp;len, charset);
<a href='../S/46.html#L118'>data</a>              118 base64.c       void b64dec_buf(const unsigned char *data, size_t *len, char *dest, const char* charset_index)
<a href='../S/46.html#L130'>data</a>              130 base64.c           *buf++ = (charset_index[data[0]] &lt;&lt; 2) + ((charset_index[data[1]] &amp; 0x30) &gt;&gt; 4);  /* 0x30 not required but to be clear. */
<a href='../S/46.html#L131'>data</a>              131 base64.c           if (data[2] != PADDING_CHAR) {
<a href='../S/46.html#L133'>data</a>              133 base64.c             *buf++ = ((charset_index[data[1]] &amp; 0x0f) &lt;&lt; 4) + ((charset_index[data[2]] &amp; 0x3c) &gt;&gt; 2);
<a href='../S/46.html#L134'>data</a>              134 base64.c             if (data[3] != PADDING_CHAR) {
<a href='../S/46.html#L136'>data</a>              136 base64.c               *buf++ = ((charset_index[data[2]] &amp; 0x03) &lt;&lt; 6) + charset_index[data[3]];
<a href='../S/46.html#L139'>data</a>              139 base64.c           data += NUM_ENCODED_BYTES;
<a href='../S/46.html#L146'>data</a>              146 base64.c       char *b64dec(const unsigned char *data, size_t *len, const char* charset)
<a href='../S/46.html#L156'>data</a>              156 base64.c           b64dec_buf(data, len, dest, charset_index);
<a href='../S/46.html#L158'>data</a>              158 base64.c           b64dec_buf(data, len, dest);
<a href='../S/46.html#L165'>data</a>              165 base64.c         char *p = b64dec(reinterpret_cast&lt;const unsigned char*&gt;(string.data()), &amp;len, charset);
<a href='../S/38.html#L79'>data</a>               79 base64.h       void b64enc_buf(const unsigned char *data, size_t *len, char *dest, const char* charset = NULL);
<a href='../S/38.html#L88'>data</a>               88 base64.h       char *b64dec(const unsigned char *data, size_t *len, const char* charset = NULL);
<a href='../S/38.html#L105'>data</a>              105 base64.h       void b64dec_buf(const unsigned char *data, size_t *len, char *dest, const char* charset_index = NULL);
</pre>
</body>
</html>
